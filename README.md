Il progetto ha come scopo finale presentare un simulatore di un Multi CPU Scheduler, al quale ho aggiunto anche la possibilità di scegliere tra 3 possibili opzioni la politica di scheduling: Round Robin, Shortest Remaining Job First e Priority con ageing delle priorità.
Per implementare la possibilità di scegliere più core disponibili per i processi, ho modificato nella struct FakeOS in fake_os.h quello che inizialmente era un puntatore a FakePCB (running) in una linked list di puntatori a FakePCB, le principali modifiche sono avvenute in fake_os.c dove ogni volta viene eseguito un passo dal sistema operativo di tipo FakeOS, quindi il programma farà una scansione della linked list controllando per ogni processo in esecuzione il suo stato ed eventualmente, se sono state scelte le politiche SRJF o su priorità, controllare se nella coda di ready sono presenti processi con maggior diritto alla cpu per poter effettuare preempting.
Per quanto riguarda lo scheduling, lo scheduler presente in sched_sim.c viene invocato ogni volta che la cpu ha almeno un core libero e se è presente almeno un processo nella coda dei ready.
Ovviamente se un core è libero significa che non ci sono altri processi da dare al core, che un processo ha terminato il suo CPU burst o il quanto assegnatogli oppure ancora se è stato tirato fuori a causa di preempting.
Per controllare se almeno un core è libero ho dovuto implementare in linked_list.c, la funzione List_isFull che verifica se il numero di nodi della lista sia minore del numero massimo di nodi possibili, a tal scopo ho aggiunto il campo maxsize (che viene settato al numero di core voluto dall'utente in FakeOS_init) nella struct ListHead presente in linked_list.h
Quando viene chiamato lo scheduler questi sceglie il prossimo processo da assegnare alla cpu a seconda della politica di scheduling scelta dall'utente (controllo della variabile scheduler)
Per quanto riguarda le politiche di scheduling, il Round Robin era essenzialmente già implementato e sceglie come prossimo processo il primo presente nella coda di ready; per il SRJF invece viene eseguita la scansione dell'intera coda di ready e man mano viene scelto il processo con durata rimanente minore.
Per lo scheduling basato su priorità molto similmente al precedente viene scansionata la lista dei ready per scegliere il primo processo con maggior priorità, ma l'implementazione cambia abbastanza con l'introduzione dell'invecchiamento, infatti per evitare lo starving ho fatto si che ogni 20 unità di tempo che un processo passa in attesa senza riuscire a completare un quanto in cpu la sua priorità aumenta di 1, per far ciò ho dovuto aggiungere 3 campi a FakeProcess e FakePCB, prio, temp_prio e counter. Prio è la priorità che gli viene assegnata a inizio esecuzione con la lettura dei file di testo(se una priorità è assente allora viene settata massima priorità:1 notificando l'utente tramite una printf), temp_prio invece è quella che effettivamente viene controllata dallo scheduler perchè è quella che viene modificata nell'invecchiamento e riportata al valore iniziale prio quando riesce a completare un quanto di esecuzione o un cpu burst e infine counter serve per tener traccia del tempo passato, viene incrementato di uno ogni volta che un processo passa un'unità di tempo in attesa nella ready, quando raggiunge 20 la temp_prio viene decrementata fino a un massimo di 1,e il contatore riazzerato.
Per prendere i paramentri dall'utente ho modificato la prte iniziale del main in sched_sim.c per modificare delle variabili: nuclei, scheduler e quanto rappresentanti il numero di core, il tipo di scheduling e la dimensione del quanto, se l'utente inserisce paramentri non validi il programma se ne accorge stampando il messaggio d'errore specifico e interrompendo l'esecuzione.
Per eseguire il programma bisogna spostarsi sulla cartella example e da li eseguire : 
	../sched_sim x y z process*.txt
dove x è il numero di core, y la politica di scheduling,z la grandezza del quanto e process*.txt i processi da dare in pasto alla cpu (quelli presenti in example), inoltre è sufficente eseguire ../sched_sim poichè il programma andrà in errore ma prima di fare ciò stamperà un messaggio contenente le informazioni su tutti i parametri necessari da passare.
All'interno di example sono presenti vari tipi di processi costruiti appositamente per esaltare le modifiche che si applicano alla cpu e allo scheduler:
ag_prio* e _prio* esaltano lo scheduling basato su priorità e l'invecchiamento  .
quad* esa* e octa* esaltano lo scheduling con cpu a rispettivamente 4,6,8 core (tutti e tre i tipo di processi sono costitui da processi tra loro uguali) .
srjf* ovviamente per esaltare lo scheduling srjf
p* sono processi generici
Ovviamente ogni tipo di processo può essere eseguito con qualsiasi combinazione di politica e numero di core.



